{"ast":null,"code":"//1. Problem → 2. Concept → 3. Application\n\nconst TopicData = [{\n  img: '/designPatterns.avif',\n  title: 'Design Patterns',\n  paragraph: [\"Have you ever heard someone say programming is like building with Legos? It’s a fun comparison—but in truth, programming goes far beyond snapping blocks together. You can’t use Legos to analyze genetic data or record real-time environmental changes. Yet, on a syntactic level, programming has recurring structures—common building blocks—that guide the flow of logic. These structures scale into design patterns: reusable solutions to frequent problems that occur across different software domains.\", \"What makes design patterns powerful is that they transcend specific programming languages. They're not just about syntax—they operate on a meta-layer, helping answer how a developer might implement user stories in a way that aligns with project needs. This is crucial, because code isn’t truly functional unless it meets user expectations. Design patterns help bridge that gap between \\\"what the user needs\\\" and \\\"how the system delivers it.\\\" In that sense, they become not only technical solutions but also tools for collaboration, communication, and clarity.\"]\n}, {\n  img: '/OOP.avif',\n  title: 'Object-Oriented Programming (OOP)',\n  paragraph: [\"What’s a chair? It’s a deceptively simple question—one I first encountered in an introductory psychology class. The purpose wasn’t to define furniture, but to provoke a deeper insight: the idea of a schema—a mental model that helps us categorize and understand the world.\", \"In computer science, this same concept appears as a class. A class defines the blueprint for an object, capturing both its data and its behaviors. Just as our schema for \\\"chair\\\" might include four legs and a surface to sit on, a class defines what attributes and actions its objects can have.\", \"This abstraction is the foundation of Object-Oriented Programming (OOP). By modeling real-world entities through classes and objects, developers can build software that is modular, reusable, and easier to reason about. Sometimes, these abstractions go beyond static definitions—supporting polymorphism, encapsulation, and inheritance to mirror complex, real-world relationships. In that way, OOP is more than a technique; it’s a paradigm for how we design and structure digital systems.\"]\n}, {\n  img: '/SDLC.avif',\n  title: 'Software Development Life Cycle (SDLC)',\n  paragraph: [\"\\'So what’s the plan?\\' Whenever someone asks that, you know something serious is about to happen. In software development, that same urgency applies. Projects are high-stakes, complex, and resource-intensive—and that’s where the SDLC comes in. It serves as a playbook to reduce uncertainty and bring order to an inherently unpredictable process.\", \"This might sound like an impossible task—but the key isn’t perfection. It’s the principle of building things “just barely good enough.” That mindset helps teams work efficiently and adaptively, especially when resources are limited or stakeholder needs shift.\", \"This is why rigid, linear models like Waterfall often struggle at scale. Their strength—structure—can also be their downfall when requirements evolve. In contrast, modular or iterative approaches like Agile can self-correct mid-course, sacrificing a small piece to save the bigger picture. The SDLC gives teams a framework to choose the right model and strike a balance between structure and flexibility.\"]\n}, {\n  img: '/linearAlgebra.avif',\n  title: 'Linear Algebra',\n  paragraph: [\"Linear algebra was the moment mathematics stopped feeling like a subject and started feeling like a language. When I first began working with matrices, I realized I wasn’t just manipulating numbers—I was transforming relationships. Every vector, every span, felt like a sentence describing how systems connect. It brought together everything I had learned before: algebra, geometry, statistics—all converging into a single, coherent structure. That moment changed how I saw math forever.\", \"What fascinates me most about linear algebra is how it reveals truth in higher dimensions. It gives form to patterns too complex for intuition alone—turning abstract relationships into geometry and motion. Through matrices, we can model uncertainty, discover latent structure, and quantify meaning. This isn’t just computation; it’s translation—the conversion of chaos into clarity. In this space, numbers stop being static and start becoming alive, encoding the essence of systems both natural and artificial.\", \"I see linear algebra as the foundation of understanding intelligence—human or machine. It is the bridge between data and insight, between perception and reasoning. Every neural network, every optimization, every projection of thought onto structure rests on its principles. For me, working with matrices feels like speaking to the universe in its own dialect—a dialect that connects logic, beauty, and truth. And through that connection, I hope to build models that don’t just solve problems, but deepen our understanding of the world itself.\"]\n}];\nexport default TopicData;","map":{"version":3,"names":["TopicData","img","title","paragraph"],"sources":["C:/Users/Matth/Desktop/Master Dell Laptop/Development/Portfolio3/src/components/topicData.js"],"sourcesContent":["//1. Problem → 2. Concept → 3. Application\r\n\r\nconst TopicData = [\r\n  {\r\n    img: '/designPatterns.avif',\r\n    title: 'Design Patterns',\r\n    paragraph: [\r\n      \"Have you ever heard someone say programming is like building with Legos? It’s a fun comparison—but in truth, programming goes far beyond snapping blocks together. You can’t use Legos to analyze genetic data or record real-time environmental changes. Yet, on a syntactic level, programming has recurring structures—common building blocks—that guide the flow of logic. These structures scale into design patterns: reusable solutions to frequent problems that occur across different software domains.\",\r\n\r\n      \"What makes design patterns powerful is that they transcend specific programming languages. They're not just about syntax—they operate on a meta-layer, helping answer how a developer might implement user stories in a way that aligns with project needs. This is crucial, because code isn’t truly functional unless it meets user expectations. Design patterns help bridge that gap between \\\"what the user needs\\\" and \\\"how the system delivers it.\\\" In that sense, they become not only technical solutions but also tools for collaboration, communication, and clarity.\"\r\n    ]\r\n  },\r\n  {\r\n  img: '/OOP.avif',\r\n  title: 'Object-Oriented Programming (OOP)',\r\n  paragraph: [\r\n    \"What’s a chair? It’s a deceptively simple question—one I first encountered in an introductory psychology class. The purpose wasn’t to define furniture, but to provoke a deeper insight: the idea of a schema—a mental model that helps us categorize and understand the world.\",\r\n\r\n    \"In computer science, this same concept appears as a class. A class defines the blueprint for an object, capturing both its data and its behaviors. Just as our schema for \\\"chair\\\" might include four legs and a surface to sit on, a class defines what attributes and actions its objects can have.\",\r\n\r\n    \"This abstraction is the foundation of Object-Oriented Programming (OOP). By modeling real-world entities through classes and objects, developers can build software that is modular, reusable, and easier to reason about. Sometimes, these abstractions go beyond static definitions—supporting polymorphism, encapsulation, and inheritance to mirror complex, real-world relationships. In that way, OOP is more than a technique; it’s a paradigm for how we design and structure digital systems.\"\r\n  ]\r\n},   \r\n{\r\n  img: '/SDLC.avif',\r\n  title: 'Software Development Life Cycle (SDLC)',\r\n  paragraph: [\r\n    \"\\'So what’s the plan?\\' Whenever someone asks that, you know something serious is about to happen. In software development, that same urgency applies. Projects are high-stakes, complex, and resource-intensive—and that’s where the SDLC comes in. It serves as a playbook to reduce uncertainty and bring order to an inherently unpredictable process.\",\r\n\r\n    \"This might sound like an impossible task—but the key isn’t perfection. It’s the principle of building things “just barely good enough.” That mindset helps teams work efficiently and adaptively, especially when resources are limited or stakeholder needs shift.\",\r\n    \r\n    \"This is why rigid, linear models like Waterfall often struggle at scale. Their strength—structure—can also be their downfall when requirements evolve. In contrast, modular or iterative approaches like Agile can self-correct mid-course, sacrificing a small piece to save the bigger picture. The SDLC gives teams a framework to choose the right model and strike a balance between structure and flexibility.\"\r\n]\r\n},\r\n{\r\n  img: '/linearAlgebra.avif',\r\n  title: 'Linear Algebra',\r\n  paragraph: [\r\n    \"Linear algebra was the moment mathematics stopped feeling like a subject and started feeling like a language. When I first began working with matrices, I realized I wasn’t just manipulating numbers—I was transforming relationships. Every vector, every span, felt like a sentence describing how systems connect. It brought together everything I had learned before: algebra, geometry, statistics—all converging into a single, coherent structure. That moment changed how I saw math forever.\",\r\n\r\n    \"What fascinates me most about linear algebra is how it reveals truth in higher dimensions. It gives form to patterns too complex for intuition alone—turning abstract relationships into geometry and motion. Through matrices, we can model uncertainty, discover latent structure, and quantify meaning. This isn’t just computation; it’s translation—the conversion of chaos into clarity. In this space, numbers stop being static and start becoming alive, encoding the essence of systems both natural and artificial.\",\r\n\r\n    \"I see linear algebra as the foundation of understanding intelligence—human or machine. It is the bridge between data and insight, between perception and reasoning. Every neural network, every optimization, every projection of thought onto structure rests on its principles. For me, working with matrices feels like speaking to the universe in its own dialect—a dialect that connects logic, beauty, and truth. And through that connection, I hope to build models that don’t just solve problems, but deepen our understanding of the world itself.\"\r\n  ]\r\n}\r\n];\r\n\r\nexport default TopicData;\r\n\r\n\r\n"],"mappings":"AAAA;;AAEA,MAAMA,SAAS,GAAG,CAChB;EACEC,GAAG,EAAE,sBAAsB;EAC3BC,KAAK,EAAE,iBAAiB;EACxBC,SAAS,EAAE,CACT,mfAAmf,EAEnf,ojBAAojB;AAExjB,CAAC,EACD;EACAF,GAAG,EAAE,WAAW;EAChBC,KAAK,EAAE,mCAAmC;EAC1CC,SAAS,EAAE,CACT,iRAAiR,EAEjR,wSAAwS,EAExS,weAAwe;AAE5e,CAAC,EACD;EACEF,GAAG,EAAE,YAAY;EACjBC,KAAK,EAAE,wCAAwC;EAC/CC,SAAS,EAAE,CACT,4VAA4V,EAE5V,qQAAqQ,EAErQ,sZAAsZ;AAE1Z,CAAC,EACD;EACEF,GAAG,EAAE,qBAAqB;EAC1BC,KAAK,EAAE,gBAAgB;EACvBC,SAAS,EAAE,CACT,yeAAye,EAEze,ggBAAggB,EAEhgB,giBAAgiB;AAEpiB,CAAC,CACA;AAED,eAAeH,SAAS","ignoreList":[]},"metadata":{},"sourceType":"module","externalDependencies":[]}