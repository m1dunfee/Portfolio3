{"ast":null,"code":"\"use strict\";\n\nObject.defineProperty(exports, \"__esModule\", {\n  value: true\n});\nexports.TSAnyKeyword = TSAnyKeyword;\nexports.TSArrayType = TSArrayType;\nexports.TSSatisfiesExpression = exports.TSAsExpression = TSTypeExpression;\nexports.TSBigIntKeyword = TSBigIntKeyword;\nexports.TSBooleanKeyword = TSBooleanKeyword;\nexports.TSCallSignatureDeclaration = TSCallSignatureDeclaration;\nexports.TSInterfaceHeritage = exports.TSExpressionWithTypeArguments = exports.TSClassImplements = TSClassImplements;\nexports.TSConditionalType = TSConditionalType;\nexports.TSConstructSignatureDeclaration = TSConstructSignatureDeclaration;\nexports.TSConstructorType = TSConstructorType;\nexports.TSDeclareFunction = TSDeclareFunction;\nexports.TSDeclareMethod = TSDeclareMethod;\nexports.TSEnumDeclaration = TSEnumDeclaration;\nexports.TSEnumMember = TSEnumMember;\nexports.TSExportAssignment = TSExportAssignment;\nexports.TSExternalModuleReference = TSExternalModuleReference;\nexports.TSFunctionType = TSFunctionType;\nexports.TSImportEqualsDeclaration = TSImportEqualsDeclaration;\nexports.TSImportType = TSImportType;\nexports.TSIndexSignature = TSIndexSignature;\nexports.TSIndexedAccessType = TSIndexedAccessType;\nexports.TSInferType = TSInferType;\nexports.TSInstantiationExpression = TSInstantiationExpression;\nexports.TSInterfaceBody = TSInterfaceBody;\nexports.TSInterfaceDeclaration = TSInterfaceDeclaration;\nexports.TSIntersectionType = TSIntersectionType;\nexports.TSIntrinsicKeyword = TSIntrinsicKeyword;\nexports.TSLiteralType = TSLiteralType;\nexports.TSMappedType = TSMappedType;\nexports.TSMethodSignature = TSMethodSignature;\nexports.TSModuleBlock = TSModuleBlock;\nexports.TSModuleDeclaration = TSModuleDeclaration;\nexports.TSNamedTupleMember = TSNamedTupleMember;\nexports.TSNamespaceExportDeclaration = TSNamespaceExportDeclaration;\nexports.TSNeverKeyword = TSNeverKeyword;\nexports.TSNonNullExpression = TSNonNullExpression;\nexports.TSNullKeyword = TSNullKeyword;\nexports.TSNumberKeyword = TSNumberKeyword;\nexports.TSObjectKeyword = TSObjectKeyword;\nexports.TSOptionalType = TSOptionalType;\nexports.TSParameterProperty = TSParameterProperty;\nexports.TSParenthesizedType = TSParenthesizedType;\nexports.TSPropertySignature = TSPropertySignature;\nexports.TSQualifiedName = TSQualifiedName;\nexports.TSRestType = TSRestType;\nexports.TSStringKeyword = TSStringKeyword;\nexports.TSSymbolKeyword = TSSymbolKeyword;\nexports.TSThisType = TSThisType;\nexports.TSTupleType = TSTupleType;\nexports.TSTypeAliasDeclaration = TSTypeAliasDeclaration;\nexports.TSTypeAnnotation = TSTypeAnnotation;\nexports.TSTypeAssertion = TSTypeAssertion;\nexports.TSTypeLiteral = TSTypeLiteral;\nexports.TSTypeOperator = TSTypeOperator;\nexports.TSTypeParameter = TSTypeParameter;\nexports.TSTypeParameterDeclaration = exports.TSTypeParameterInstantiation = TSTypeParameterInstantiation;\nexports.TSTypePredicate = TSTypePredicate;\nexports.TSTypeQuery = TSTypeQuery;\nexports.TSTypeReference = TSTypeReference;\nexports.TSUndefinedKeyword = TSUndefinedKeyword;\nexports.TSUnionType = TSUnionType;\nexports.TSUnknownKeyword = TSUnknownKeyword;\nexports.TSVoidKeyword = TSVoidKeyword;\nexports.tsPrintClassMemberModifiers = tsPrintClassMemberModifiers;\nexports.tsPrintFunctionOrConstructorType = tsPrintFunctionOrConstructorType;\nexports.tsPrintPropertyOrMethodName = tsPrintPropertyOrMethodName;\nexports.tsPrintSignatureDeclarationBase = tsPrintSignatureDeclarationBase;\nfunction TSTypeAnnotation(node, parent) {\n  this.token((parent.type === \"TSFunctionType\" || parent.type === \"TSConstructorType\") && parent.typeAnnotation === node ? \"=>\" : \":\");\n  this.space();\n  if (node.optional) this.tokenChar(63);\n  this.print(node.typeAnnotation);\n}\nfunction TSTypeParameterInstantiation(node, parent) {\n  this.tokenChar(60);\n  let printTrailingSeparator = parent.type === \"ArrowFunctionExpression\" && node.params.length === 1;\n  if (this.tokenMap && node.start != null && node.end != null) {\n    printTrailingSeparator && (printTrailingSeparator = !!this.tokenMap.find(node, t => this.tokenMap.matchesOriginal(t, \",\")));\n    printTrailingSeparator || (printTrailingSeparator = this.shouldPrintTrailingComma(\">\"));\n  }\n  this.printList(node.params, printTrailingSeparator);\n  this.tokenChar(62);\n}\nfunction TSTypeParameter(node) {\n  if (node.in) {\n    this.word(\"in\");\n    this.space();\n  }\n  if (node.out) {\n    this.word(\"out\");\n    this.space();\n  }\n  this.word(node.name);\n  if (node.constraint) {\n    this.space();\n    this.word(\"extends\");\n    this.space();\n    this.print(node.constraint);\n  }\n  if (node.default) {\n    this.space();\n    this.tokenChar(61);\n    this.space();\n    this.print(node.default);\n  }\n}\nfunction TSParameterProperty(node) {\n  if (node.accessibility) {\n    this.word(node.accessibility);\n    this.space();\n  }\n  if (node.readonly) {\n    this.word(\"readonly\");\n    this.space();\n  }\n  this._param(node.parameter);\n}\nfunction TSDeclareFunction(node, parent) {\n  if (node.declare) {\n    this.word(\"declare\");\n    this.space();\n  }\n  this._functionHead(node, parent);\n  this.semicolon();\n}\nfunction TSDeclareMethod(node) {\n  this._classMethodHead(node);\n  this.semicolon();\n}\nfunction TSQualifiedName(node) {\n  this.print(node.left);\n  this.tokenChar(46);\n  this.print(node.right);\n}\nfunction TSCallSignatureDeclaration(node) {\n  this.tsPrintSignatureDeclarationBase(node);\n  maybePrintTrailingCommaOrSemicolon(this, node);\n}\nfunction maybePrintTrailingCommaOrSemicolon(printer, node) {\n  if (!printer.tokenMap || !node.start || !node.end) {\n    printer.semicolon();\n    return;\n  }\n  if (printer.tokenMap.endMatches(node, \",\")) {\n    printer.token(\",\");\n  } else if (printer.tokenMap.endMatches(node, \";\")) {\n    printer.semicolon();\n  }\n}\nfunction TSConstructSignatureDeclaration(node) {\n  this.word(\"new\");\n  this.space();\n  this.tsPrintSignatureDeclarationBase(node);\n  maybePrintTrailingCommaOrSemicolon(this, node);\n}\nfunction TSPropertySignature(node) {\n  const {\n    readonly\n  } = node;\n  if (readonly) {\n    this.word(\"readonly\");\n    this.space();\n  }\n  this.tsPrintPropertyOrMethodName(node);\n  this.print(node.typeAnnotation);\n  maybePrintTrailingCommaOrSemicolon(this, node);\n}\nfunction tsPrintPropertyOrMethodName(node) {\n  if (node.computed) {\n    this.tokenChar(91);\n  }\n  this.print(node.key);\n  if (node.computed) {\n    this.tokenChar(93);\n  }\n  if (node.optional) {\n    this.tokenChar(63);\n  }\n}\nfunction TSMethodSignature(node) {\n  const {\n    kind\n  } = node;\n  if (kind === \"set\" || kind === \"get\") {\n    this.word(kind);\n    this.space();\n  }\n  this.tsPrintPropertyOrMethodName(node);\n  this.tsPrintSignatureDeclarationBase(node);\n  maybePrintTrailingCommaOrSemicolon(this, node);\n}\nfunction TSIndexSignature(node) {\n  const {\n    readonly,\n    static: isStatic\n  } = node;\n  if (isStatic) {\n    this.word(\"static\");\n    this.space();\n  }\n  if (readonly) {\n    this.word(\"readonly\");\n    this.space();\n  }\n  this.tokenChar(91);\n  this._parameters(node.parameters, \"]\");\n  this.print(node.typeAnnotation);\n  maybePrintTrailingCommaOrSemicolon(this, node);\n}\nfunction TSAnyKeyword() {\n  this.word(\"any\");\n}\nfunction TSBigIntKeyword() {\n  this.word(\"bigint\");\n}\nfunction TSUnknownKeyword() {\n  this.word(\"unknown\");\n}\nfunction TSNumberKeyword() {\n  this.word(\"number\");\n}\nfunction TSObjectKeyword() {\n  this.word(\"object\");\n}\nfunction TSBooleanKeyword() {\n  this.word(\"boolean\");\n}\nfunction TSStringKeyword() {\n  this.word(\"string\");\n}\nfunction TSSymbolKeyword() {\n  this.word(\"symbol\");\n}\nfunction TSVoidKeyword() {\n  this.word(\"void\");\n}\nfunction TSUndefinedKeyword() {\n  this.word(\"undefined\");\n}\nfunction TSNullKeyword() {\n  this.word(\"null\");\n}\nfunction TSNeverKeyword() {\n  this.word(\"never\");\n}\nfunction TSIntrinsicKeyword() {\n  this.word(\"intrinsic\");\n}\nfunction TSThisType() {\n  this.word(\"this\");\n}\nfunction TSFunctionType(node) {\n  this.tsPrintFunctionOrConstructorType(node);\n}\nfunction TSConstructorType(node) {\n  if (node.abstract) {\n    this.word(\"abstract\");\n    this.space();\n  }\n  this.word(\"new\");\n  this.space();\n  this.tsPrintFunctionOrConstructorType(node);\n}\nfunction tsPrintFunctionOrConstructorType(node) {\n  const {\n    typeParameters\n  } = node;\n  const parameters = node.parameters;\n  this.print(typeParameters);\n  this.tokenChar(40);\n  this._parameters(parameters, \")\");\n  this.space();\n  const returnType = node.typeAnnotation;\n  this.print(returnType);\n}\nfunction TSTypeReference(node) {\n  this.print(node.typeName, !!node.typeParameters);\n  this.print(node.typeParameters);\n}\nfunction TSTypePredicate(node) {\n  if (node.asserts) {\n    this.word(\"asserts\");\n    this.space();\n  }\n  this.print(node.parameterName);\n  if (node.typeAnnotation) {\n    this.space();\n    this.word(\"is\");\n    this.space();\n    this.print(node.typeAnnotation.typeAnnotation);\n  }\n}\nfunction TSTypeQuery(node) {\n  this.word(\"typeof\");\n  this.space();\n  this.print(node.exprName);\n  if (node.typeParameters) {\n    this.print(node.typeParameters);\n  }\n}\nfunction TSTypeLiteral(node) {\n  printBraced(this, node, () => this.printJoin(node.members, true, true));\n}\nfunction TSArrayType(node) {\n  this.print(node.elementType, true);\n  this.tokenChar(91);\n  this.tokenChar(93);\n}\nfunction TSTupleType(node) {\n  this.tokenChar(91);\n  this.printList(node.elementTypes, this.shouldPrintTrailingComma(\"]\"));\n  this.tokenChar(93);\n}\nfunction TSOptionalType(node) {\n  this.print(node.typeAnnotation);\n  this.tokenChar(63);\n}\nfunction TSRestType(node) {\n  this.token(\"...\");\n  this.print(node.typeAnnotation);\n}\nfunction TSNamedTupleMember(node) {\n  this.print(node.label);\n  if (node.optional) this.tokenChar(63);\n  this.tokenChar(58);\n  this.space();\n  this.print(node.elementType);\n}\nfunction TSUnionType(node) {\n  tsPrintUnionOrIntersectionType(this, node, \"|\");\n}\nfunction TSIntersectionType(node) {\n  tsPrintUnionOrIntersectionType(this, node, \"&\");\n}\nfunction tsPrintUnionOrIntersectionType(printer, node, sep) {\n  var _printer$tokenMap;\n  let hasLeadingToken = 0;\n  if ((_printer$tokenMap = printer.tokenMap) != null && _printer$tokenMap.startMatches(node, sep)) {\n    hasLeadingToken = 1;\n    printer.token(sep);\n  }\n  printer.printJoin(node.types, undefined, undefined, function (i) {\n    this.space();\n    this.token(sep, null, i + hasLeadingToken);\n    this.space();\n  });\n}\nfunction TSConditionalType(node) {\n  this.print(node.checkType);\n  this.space();\n  this.word(\"extends\");\n  this.space();\n  this.print(node.extendsType);\n  this.space();\n  this.tokenChar(63);\n  this.space();\n  this.print(node.trueType);\n  this.space();\n  this.tokenChar(58);\n  this.space();\n  this.print(node.falseType);\n}\nfunction TSInferType(node) {\n  this.word(\"infer\");\n  this.print(node.typeParameter);\n}\nfunction TSParenthesizedType(node) {\n  this.tokenChar(40);\n  this.print(node.typeAnnotation);\n  this.tokenChar(41);\n}\nfunction TSTypeOperator(node) {\n  this.word(node.operator);\n  this.space();\n  this.print(node.typeAnnotation);\n}\nfunction TSIndexedAccessType(node) {\n  this.print(node.objectType, true);\n  this.tokenChar(91);\n  this.print(node.indexType);\n  this.tokenChar(93);\n}\nfunction TSMappedType(node) {\n  const {\n    nameType,\n    optional,\n    readonly,\n    typeAnnotation\n  } = node;\n  this.tokenChar(123);\n  const exit = this.enterDelimited();\n  this.space();\n  if (readonly) {\n    tokenIfPlusMinus(this, readonly);\n    this.word(\"readonly\");\n    this.space();\n  }\n  this.tokenChar(91);\n  {\n    this.word(node.typeParameter.name);\n  }\n  this.space();\n  this.word(\"in\");\n  this.space();\n  {\n    this.print(node.typeParameter.constraint);\n  }\n  if (nameType) {\n    this.space();\n    this.word(\"as\");\n    this.space();\n    this.print(nameType);\n  }\n  this.tokenChar(93);\n  if (optional) {\n    tokenIfPlusMinus(this, optional);\n    this.tokenChar(63);\n  }\n  if (typeAnnotation) {\n    this.tokenChar(58);\n    this.space();\n    this.print(typeAnnotation);\n  }\n  this.space();\n  exit();\n  this.tokenChar(125);\n}\nfunction tokenIfPlusMinus(self, tok) {\n  if (tok !== true) {\n    self.token(tok);\n  }\n}\nfunction TSLiteralType(node) {\n  this.print(node.literal);\n}\nfunction TSClassImplements(node) {\n  this.print(node.expression);\n  this.print(node.typeParameters);\n}\nfunction TSInterfaceDeclaration(node) {\n  const {\n    declare,\n    id,\n    typeParameters,\n    extends: extendz,\n    body\n  } = node;\n  if (declare) {\n    this.word(\"declare\");\n    this.space();\n  }\n  this.word(\"interface\");\n  this.space();\n  this.print(id);\n  this.print(typeParameters);\n  if (extendz != null && extendz.length) {\n    this.space();\n    this.word(\"extends\");\n    this.space();\n    this.printList(extendz);\n  }\n  this.space();\n  this.print(body);\n}\nfunction TSInterfaceBody(node) {\n  printBraced(this, node, () => this.printJoin(node.body, true, true));\n}\nfunction TSTypeAliasDeclaration(node) {\n  const {\n    declare,\n    id,\n    typeParameters,\n    typeAnnotation\n  } = node;\n  if (declare) {\n    this.word(\"declare\");\n    this.space();\n  }\n  this.word(\"type\");\n  this.space();\n  this.print(id);\n  this.print(typeParameters);\n  this.space();\n  this.tokenChar(61);\n  this.space();\n  this.print(typeAnnotation);\n  this.semicolon();\n}\nfunction TSTypeExpression(node) {\n  const {\n    type,\n    expression,\n    typeAnnotation\n  } = node;\n  this.print(expression, true);\n  this.space();\n  this.word(type === \"TSAsExpression\" ? \"as\" : \"satisfies\");\n  this.space();\n  this.print(typeAnnotation);\n}\nfunction TSTypeAssertion(node) {\n  const {\n    typeAnnotation,\n    expression\n  } = node;\n  this.tokenChar(60);\n  this.print(typeAnnotation);\n  this.tokenChar(62);\n  this.space();\n  this.print(expression);\n}\nfunction TSInstantiationExpression(node) {\n  this.print(node.expression);\n  this.print(node.typeParameters);\n}\nfunction TSEnumDeclaration(node) {\n  const {\n    declare,\n    const: isConst,\n    id,\n    members\n  } = node;\n  if (declare) {\n    this.word(\"declare\");\n    this.space();\n  }\n  if (isConst) {\n    this.word(\"const\");\n    this.space();\n  }\n  this.word(\"enum\");\n  this.space();\n  this.print(id);\n  this.space();\n  printBraced(this, node, () => {\n    var _this$shouldPrintTrai;\n    return this.printList(members, (_this$shouldPrintTrai = this.shouldPrintTrailingComma(\"}\")) != null ? _this$shouldPrintTrai : true, true, true);\n  });\n}\nfunction TSEnumMember(node) {\n  const {\n    id,\n    initializer\n  } = node;\n  this.print(id);\n  if (initializer) {\n    this.space();\n    this.tokenChar(61);\n    this.space();\n    this.print(initializer);\n  }\n}\nfunction TSModuleDeclaration(node) {\n  const {\n    declare,\n    id,\n    kind\n  } = node;\n  if (declare) {\n    this.word(\"declare\");\n    this.space();\n  }\n  {\n    if (!node.global) {\n      this.word(kind != null ? kind : id.type === \"Identifier\" ? \"namespace\" : \"module\");\n      this.space();\n    }\n    this.print(id);\n    if (!node.body) {\n      this.semicolon();\n      return;\n    }\n    let body = node.body;\n    while (body.type === \"TSModuleDeclaration\") {\n      this.tokenChar(46);\n      this.print(body.id);\n      body = body.body;\n    }\n    this.space();\n    this.print(body);\n  }\n}\nfunction TSModuleBlock(node) {\n  printBraced(this, node, () => this.printSequence(node.body, true));\n}\nfunction TSImportType(node) {\n  const {\n    argument,\n    qualifier,\n    typeParameters\n  } = node;\n  this.word(\"import\");\n  this.tokenChar(40);\n  this.print(argument);\n  this.tokenChar(41);\n  if (qualifier) {\n    this.tokenChar(46);\n    this.print(qualifier);\n  }\n  if (typeParameters) {\n    this.print(typeParameters);\n  }\n}\nfunction TSImportEqualsDeclaration(node) {\n  const {\n    isExport,\n    id,\n    moduleReference\n  } = node;\n  if (isExport) {\n    this.word(\"export\");\n    this.space();\n  }\n  this.word(\"import\");\n  this.space();\n  this.print(id);\n  this.space();\n  this.tokenChar(61);\n  this.space();\n  this.print(moduleReference);\n  this.semicolon();\n}\nfunction TSExternalModuleReference(node) {\n  this.token(\"require(\");\n  this.print(node.expression);\n  this.tokenChar(41);\n}\nfunction TSNonNullExpression(node) {\n  this.print(node.expression);\n  this.tokenChar(33);\n}\nfunction TSExportAssignment(node) {\n  this.word(\"export\");\n  this.space();\n  this.tokenChar(61);\n  this.space();\n  this.print(node.expression);\n  this.semicolon();\n}\nfunction TSNamespaceExportDeclaration(node) {\n  this.word(\"export\");\n  this.space();\n  this.word(\"as\");\n  this.space();\n  this.word(\"namespace\");\n  this.space();\n  this.print(node.id);\n  this.semicolon();\n}\nfunction tsPrintSignatureDeclarationBase(node) {\n  const {\n    typeParameters\n  } = node;\n  const parameters = node.parameters;\n  this.print(typeParameters);\n  this.tokenChar(40);\n  this._parameters(parameters, \")\");\n  const returnType = node.typeAnnotation;\n  this.print(returnType);\n}\nfunction tsPrintClassMemberModifiers(node) {\n  const isField = node.type === \"ClassAccessorProperty\" || node.type === \"ClassProperty\";\n  printModifiersList(this, node, [isField && node.declare && \"declare\", node.accessibility]);\n  if (node.static) {\n    this.word(\"static\");\n    this.space();\n  }\n  printModifiersList(this, node, [node.override && \"override\", node.abstract && \"abstract\", isField && node.readonly && \"readonly\"]);\n}\nfunction printBraced(printer, node, cb) {\n  printer.token(\"{\");\n  const exit = printer.enterDelimited();\n  cb();\n  exit();\n  printer.rightBrace(node);\n}\nfunction printModifiersList(printer, node, modifiers) {\n  var _printer$tokenMap2;\n  const modifiersSet = new Set();\n  for (const modifier of modifiers) {\n    if (modifier) modifiersSet.add(modifier);\n  }\n  (_printer$tokenMap2 = printer.tokenMap) == null || _printer$tokenMap2.find(node, tok => {\n    if (modifiersSet.has(tok.value)) {\n      printer.token(tok.value);\n      printer.space();\n      modifiersSet.delete(tok.value);\n      return modifiersSet.size === 0;\n    }\n  });\n  for (const modifier of modifiersSet) {\n    printer.word(modifier);\n    printer.space();\n  }\n}","map":{"version":3,"names":["TSTypeAnnotation","node","parent","token","type","typeAnnotation","space","optional","tokenChar","print","TSTypeParameterInstantiation","printTrailingSeparator","params","length","tokenMap","start","end","find","t","matchesOriginal","shouldPrintTrailingComma","printList","TSTypeParameter","in","word","out","name","constraint","default","TSParameterProperty","accessibility","readonly","_param","parameter","TSDeclareFunction","declare","_functionHead","semicolon","TSDeclareMethod","_classMethodHead","TSQualifiedName","left","right","TSCallSignatureDeclaration","tsPrintSignatureDeclarationBase","maybePrintTrailingCommaOrSemicolon","printer","endMatches","TSConstructSignatureDeclaration","TSPropertySignature","tsPrintPropertyOrMethodName","computed","key","TSMethodSignature","kind","TSIndexSignature","static","isStatic","_parameters","parameters","TSAnyKeyword","TSBigIntKeyword","TSUnknownKeyword","TSNumberKeyword","TSObjectKeyword","TSBooleanKeyword","TSStringKeyword","TSSymbolKeyword","TSVoidKeyword","TSUndefinedKeyword","TSNullKeyword","TSNeverKeyword","TSIntrinsicKeyword","TSThisType","TSFunctionType","tsPrintFunctionOrConstructorType","TSConstructorType","abstract","typeParameters","returnType","TSTypeReference","typeName","TSTypePredicate","asserts","parameterName","TSTypeQuery","exprName","TSTypeLiteral","printBraced","printJoin","members","TSArrayType","elementType","TSTupleType","elementTypes","TSOptionalType","TSRestType","TSNamedTupleMember","label","TSUnionType","tsPrintUnionOrIntersectionType","TSIntersectionType","sep","_printer$tokenMap","hasLeadingToken","startMatches","types","undefined","i","TSConditionalType","checkType","extendsType","trueType","falseType","TSInferType","typeParameter","TSParenthesizedType","TSTypeOperator","operator","TSIndexedAccessType","objectType","indexType","TSMappedType","nameType","exit","enterDelimited","tokenIfPlusMinus","self","tok","TSLiteralType","literal","TSClassImplements","expression","TSInterfaceDeclaration","id","extends","extendz","body","TSInterfaceBody","TSTypeAliasDeclaration","TSTypeExpression","TSTypeAssertion","TSInstantiationExpression","TSEnumDeclaration","const","isConst","_this$shouldPrintTrai","TSEnumMember","initializer","TSModuleDeclaration","global","TSModuleBlock","printSequence","TSImportType","argument","qualifier","TSImportEqualsDeclaration","isExport","moduleReference","TSExternalModuleReference","TSNonNullExpression","TSExportAssignment","TSNamespaceExportDeclaration","tsPrintClassMemberModifiers","isField","printModifiersList","override","cb","rightBrace","modifiers","_printer$tokenMap2","modifiersSet","Set","modifier","add","has","value","delete","size"],"sources":["C:\\Users\\Matth\\Documents\\Development\\Portfolio3\\Portfolio3\\node_modules\\@babel\\generator\\src\\generators\\typescript.ts"],"sourcesContent":["import type Printer from \"../printer.ts\";\nimport type * as t from \"@babel/types\";\n\nexport function TSTypeAnnotation(\n  this: Printer,\n  node: t.TSTypeAnnotation,\n  parent: t.Node,\n) {\n  // TODO(@nicolo-ribaudo): investigate not including => in the range\n  // of the return type of an arrow function type\n  this.token(\n    (parent.type === \"TSFunctionType\" || parent.type === \"TSConstructorType\") &&\n      (process.env.BABEL_8_BREAKING\n        ? // @ts-ignore(Babel 7 vs Babel 8) Babel 8 AST shape\n          parent.returnType\n        : // @ts-ignore(Babel 7 vs Babel 8) Babel 7 AST shape\n          parent.typeAnnotation) === node\n      ? \"=>\"\n      : \":\",\n  );\n  this.space();\n  // @ts-expect-error todo(flow->ts) can this be removed? `.optional` looks to be not existing property\n  if (node.optional) this.token(\"?\");\n  this.print(node.typeAnnotation);\n}\n\nexport function TSTypeParameterInstantiation(\n  this: Printer,\n  node: t.TSTypeParameterInstantiation,\n  parent: t.Node,\n): void {\n  this.token(\"<\");\n\n  let printTrailingSeparator =\n    parent.type === \"ArrowFunctionExpression\" && node.params.length === 1;\n  if (this.tokenMap && node.start != null && node.end != null) {\n    // Only force the trailing comma for pre-existing nodes if they\n    // already had a comma (either because they were multi-param, or\n    // because they had a trailing comma)\n    printTrailingSeparator &&= !!this.tokenMap.find(node, t =>\n      this.tokenMap.matchesOriginal(t, \",\"),\n    );\n    // Preseve the trailing comma if it was there before\n    printTrailingSeparator ||= this.shouldPrintTrailingComma(\">\");\n  }\n\n  this.printList(node.params, printTrailingSeparator);\n  this.token(\">\");\n}\n\nexport { TSTypeParameterInstantiation as TSTypeParameterDeclaration };\n\nexport function TSTypeParameter(this: Printer, node: t.TSTypeParameter) {\n  if (node.in) {\n    this.word(\"in\");\n    this.space();\n  }\n\n  if (node.out) {\n    this.word(\"out\");\n    this.space();\n  }\n\n  this.word(\n    !process.env.BABEL_8_BREAKING\n      ? (node.name as unknown as string)\n      : (node.name as unknown as t.Identifier).name,\n  );\n\n  if (node.constraint) {\n    this.space();\n    this.word(\"extends\");\n    this.space();\n    this.print(node.constraint);\n  }\n\n  if (node.default) {\n    this.space();\n    this.token(\"=\");\n    this.space();\n    this.print(node.default);\n  }\n}\n\nexport function TSParameterProperty(\n  this: Printer,\n  node: t.TSParameterProperty,\n) {\n  if (node.accessibility) {\n    this.word(node.accessibility);\n    this.space();\n  }\n\n  if (node.readonly) {\n    this.word(\"readonly\");\n    this.space();\n  }\n\n  this._param(node.parameter);\n}\n\nexport function TSDeclareFunction(\n  this: Printer,\n  node: t.TSDeclareFunction,\n  parent: t.ParentMaps[\"TSDeclareFunction\"],\n) {\n  if (node.declare) {\n    this.word(\"declare\");\n    this.space();\n  }\n  this._functionHead(node, parent);\n  this.semicolon();\n}\n\nexport function TSDeclareMethod(this: Printer, node: t.TSDeclareMethod) {\n  this._classMethodHead(node);\n  this.semicolon();\n}\n\nexport function TSQualifiedName(this: Printer, node: t.TSQualifiedName) {\n  this.print(node.left);\n  this.token(\".\");\n  this.print(node.right);\n}\n\nexport function TSCallSignatureDeclaration(\n  this: Printer,\n  node: t.TSCallSignatureDeclaration,\n) {\n  this.tsPrintSignatureDeclarationBase(node);\n  maybePrintTrailingCommaOrSemicolon(this, node);\n}\n\nfunction maybePrintTrailingCommaOrSemicolon(printer: Printer, node: t.Node) {\n  if (!printer.tokenMap || !node.start || !node.end) {\n    printer.semicolon();\n    return;\n  }\n\n  if (printer.tokenMap.endMatches(node, \",\")) {\n    printer.token(\",\");\n  } else if (printer.tokenMap.endMatches(node, \";\")) {\n    printer.semicolon();\n  }\n}\n\nexport function TSConstructSignatureDeclaration(\n  this: Printer,\n  node: t.TSConstructSignatureDeclaration,\n) {\n  this.word(\"new\");\n  this.space();\n  this.tsPrintSignatureDeclarationBase(node);\n  maybePrintTrailingCommaOrSemicolon(this, node);\n}\n\nexport function TSPropertySignature(\n  this: Printer,\n  node: t.TSPropertySignature,\n) {\n  const { readonly } = node;\n  if (readonly) {\n    this.word(\"readonly\");\n    this.space();\n  }\n  this.tsPrintPropertyOrMethodName(node);\n  this.print(node.typeAnnotation);\n  maybePrintTrailingCommaOrSemicolon(this, node);\n}\n\nexport function tsPrintPropertyOrMethodName(\n  this: Printer,\n  node: t.TSPropertySignature | t.TSMethodSignature,\n) {\n  if (node.computed) {\n    this.token(\"[\");\n  }\n  this.print(node.key);\n  if (node.computed) {\n    this.token(\"]\");\n  }\n  if (node.optional) {\n    this.token(\"?\");\n  }\n}\n\nexport function TSMethodSignature(this: Printer, node: t.TSMethodSignature) {\n  const { kind } = node;\n  if (kind === \"set\" || kind === \"get\") {\n    this.word(kind);\n    this.space();\n  }\n  this.tsPrintPropertyOrMethodName(node);\n  this.tsPrintSignatureDeclarationBase(node);\n  maybePrintTrailingCommaOrSemicolon(this, node);\n}\n\nexport function TSIndexSignature(this: Printer, node: t.TSIndexSignature) {\n  const { readonly, static: isStatic } = node;\n  if (isStatic) {\n    this.word(\"static\");\n    this.space();\n  }\n  if (readonly) {\n    this.word(\"readonly\");\n    this.space();\n  }\n  this.token(\"[\");\n  this._parameters(node.parameters, \"]\");\n  this.print(node.typeAnnotation);\n  maybePrintTrailingCommaOrSemicolon(this, node);\n}\n\nexport function TSAnyKeyword(this: Printer) {\n  this.word(\"any\");\n}\nexport function TSBigIntKeyword(this: Printer) {\n  this.word(\"bigint\");\n}\nexport function TSUnknownKeyword(this: Printer) {\n  this.word(\"unknown\");\n}\nexport function TSNumberKeyword(this: Printer) {\n  this.word(\"number\");\n}\nexport function TSObjectKeyword(this: Printer) {\n  this.word(\"object\");\n}\nexport function TSBooleanKeyword(this: Printer) {\n  this.word(\"boolean\");\n}\nexport function TSStringKeyword(this: Printer) {\n  this.word(\"string\");\n}\nexport function TSSymbolKeyword(this: Printer) {\n  this.word(\"symbol\");\n}\nexport function TSVoidKeyword(this: Printer) {\n  this.word(\"void\");\n}\nexport function TSUndefinedKeyword(this: Printer) {\n  this.word(\"undefined\");\n}\nexport function TSNullKeyword(this: Printer) {\n  this.word(\"null\");\n}\nexport function TSNeverKeyword(this: Printer) {\n  this.word(\"never\");\n}\nexport function TSIntrinsicKeyword(this: Printer) {\n  this.word(\"intrinsic\");\n}\n\nexport function TSThisType(this: Printer) {\n  this.word(\"this\");\n}\n\nexport function TSFunctionType(this: Printer, node: t.TSFunctionType) {\n  this.tsPrintFunctionOrConstructorType(node);\n}\n\nexport function TSConstructorType(this: Printer, node: t.TSConstructorType) {\n  if (node.abstract) {\n    this.word(\"abstract\");\n    this.space();\n  }\n  this.word(\"new\");\n  this.space();\n  this.tsPrintFunctionOrConstructorType(node);\n}\n\nexport function tsPrintFunctionOrConstructorType(\n  this: Printer,\n  node: t.TSFunctionType | t.TSConstructorType,\n) {\n  const { typeParameters } = node;\n  const parameters = process.env.BABEL_8_BREAKING\n    ? // @ts-ignore(Babel 7 vs Babel 8) Babel 8 AST shape\n      node.params\n    : // @ts-ignore(Babel 7 vs Babel 8) Babel 7 AST shape\n      node.parameters;\n  this.print(typeParameters);\n  this.token(\"(\");\n  this._parameters(parameters, \")\");\n  this.space();\n  const returnType = process.env.BABEL_8_BREAKING\n    ? // @ts-ignore(Babel 7 vs Babel 8) Babel 8 AST shape\n      node.returnType\n    : // @ts-ignore(Babel 7 vs Babel 8) Babel 7 AST shape\n      node.typeAnnotation;\n  this.print(returnType);\n}\n\nexport function TSTypeReference(this: Printer, node: t.TSTypeReference) {\n  this.print(node.typeName, !!node.typeParameters);\n  this.print(node.typeParameters);\n}\n\nexport function TSTypePredicate(this: Printer, node: t.TSTypePredicate) {\n  if (node.asserts) {\n    this.word(\"asserts\");\n    this.space();\n  }\n  this.print(node.parameterName);\n  if (node.typeAnnotation) {\n    this.space();\n    this.word(\"is\");\n    this.space();\n    this.print(node.typeAnnotation.typeAnnotation);\n  }\n}\n\nexport function TSTypeQuery(this: Printer, node: t.TSTypeQuery) {\n  this.word(\"typeof\");\n  this.space();\n  this.print(node.exprName);\n\n  if (node.typeParameters) {\n    this.print(node.typeParameters);\n  }\n}\n\nexport function TSTypeLiteral(this: Printer, node: t.TSTypeLiteral) {\n  printBraced(this, node, () => this.printJoin(node.members, true, true));\n}\n\nexport function TSArrayType(this: Printer, node: t.TSArrayType) {\n  this.print(node.elementType, true);\n\n  this.token(\"[\");\n  this.token(\"]\");\n}\n\nexport function TSTupleType(this: Printer, node: t.TSTupleType) {\n  this.token(\"[\");\n  this.printList(node.elementTypes, this.shouldPrintTrailingComma(\"]\"));\n  this.token(\"]\");\n}\n\nexport function TSOptionalType(this: Printer, node: t.TSOptionalType) {\n  this.print(node.typeAnnotation);\n  this.token(\"?\");\n}\n\nexport function TSRestType(this: Printer, node: t.TSRestType) {\n  this.token(\"...\");\n  this.print(node.typeAnnotation);\n}\n\nexport function TSNamedTupleMember(this: Printer, node: t.TSNamedTupleMember) {\n  this.print(node.label);\n  if (node.optional) this.token(\"?\");\n  this.token(\":\");\n  this.space();\n  this.print(node.elementType);\n}\n\nexport function TSUnionType(this: Printer, node: t.TSUnionType) {\n  tsPrintUnionOrIntersectionType(this, node, \"|\");\n}\n\nexport function TSIntersectionType(this: Printer, node: t.TSIntersectionType) {\n  tsPrintUnionOrIntersectionType(this, node, \"&\");\n}\n\nfunction tsPrintUnionOrIntersectionType(\n  printer: Printer,\n  node: t.TSUnionType | t.TSIntersectionType,\n  sep: \"|\" | \"&\",\n) {\n  let hasLeadingToken = 0;\n  if (printer.tokenMap?.startMatches(node, sep)) {\n    hasLeadingToken = 1;\n    printer.token(sep);\n  }\n\n  printer.printJoin(node.types, undefined, undefined, function (i) {\n    this.space();\n    this.token(sep, null, i + hasLeadingToken);\n    this.space();\n  });\n}\n\nexport function TSConditionalType(this: Printer, node: t.TSConditionalType) {\n  this.print(node.checkType);\n  this.space();\n  this.word(\"extends\");\n  this.space();\n  this.print(node.extendsType);\n  this.space();\n  this.token(\"?\");\n  this.space();\n  this.print(node.trueType);\n  this.space();\n  this.token(\":\");\n  this.space();\n  this.print(node.falseType);\n}\n\nexport function TSInferType(this: Printer, node: t.TSInferType) {\n  this.word(\"infer\");\n  this.print(node.typeParameter);\n}\n\nexport function TSParenthesizedType(\n  this: Printer,\n  node: t.TSParenthesizedType,\n) {\n  this.token(\"(\");\n  this.print(node.typeAnnotation);\n  this.token(\")\");\n}\n\nexport function TSTypeOperator(this: Printer, node: t.TSTypeOperator) {\n  this.word(node.operator);\n  this.space();\n  this.print(node.typeAnnotation);\n}\n\nexport function TSIndexedAccessType(\n  this: Printer,\n  node: t.TSIndexedAccessType,\n) {\n  this.print(node.objectType, true);\n  this.token(\"[\");\n  this.print(node.indexType);\n  this.token(\"]\");\n}\n\nexport function TSMappedType(this: Printer, node: t.TSMappedType) {\n  const { nameType, optional, readonly, typeAnnotation } = node;\n  this.token(\"{\");\n  const exit = this.enterDelimited();\n  this.space();\n  if (readonly) {\n    tokenIfPlusMinus(this, readonly);\n    this.word(\"readonly\");\n    this.space();\n  }\n\n  this.token(\"[\");\n  if (process.env.BABEL_8_BREAKING) {\n    // @ts-ignore(Babel 7 vs Babel 8) Babel 8 AST shape\n    this.word(node.key.name);\n  } else {\n    // @ts-ignore(Babel 7 vs Babel 8) Babel 7 AST shape\n    this.word(node.typeParameter.name);\n  }\n\n  this.space();\n  this.word(\"in\");\n  this.space();\n  if (process.env.BABEL_8_BREAKING) {\n    // @ts-ignore(Babel 7 vs Babel 8) Babel 8 AST shape\n    this.print(node.constraint);\n  } else {\n    // @ts-ignore(Babel 7 vs Babel 8) Babel 7 AST shape\n    this.print(node.typeParameter.constraint);\n  }\n\n  if (nameType) {\n    this.space();\n    this.word(\"as\");\n    this.space();\n    this.print(nameType);\n  }\n\n  this.token(\"]\");\n\n  if (optional) {\n    tokenIfPlusMinus(this, optional);\n    this.token(\"?\");\n  }\n\n  if (typeAnnotation) {\n    this.token(\":\");\n    this.space();\n    this.print(typeAnnotation);\n  }\n  this.space();\n  exit();\n  this.token(\"}\");\n}\n\nfunction tokenIfPlusMinus(self: Printer, tok: true | \"+\" | \"-\") {\n  if (tok !== true) {\n    self.token(tok);\n  }\n}\n\nexport function TSLiteralType(this: Printer, node: t.TSLiteralType) {\n  this.print(node.literal);\n}\n\nexport function TSClassImplements(\n  this: Printer,\n  // TODO(Babel 8): Just use t.TSClassImplements\n  node: Extract<\n    t.Node,\n    { type: \"TSClassImplements\" | \"TSExpressionWithTypeArguments\" }\n  >,\n) {\n  this.print(node.expression);\n  this.print(node.typeParameters);\n}\n\nexport {\n  // TODO: Remove this in Babel 8\n  TSClassImplements as TSExpressionWithTypeArguments,\n  TSClassImplements as TSInterfaceHeritage,\n};\n\nexport function TSInterfaceDeclaration(\n  this: Printer,\n  node: t.TSInterfaceDeclaration,\n) {\n  const { declare, id, typeParameters, extends: extendz, body } = node;\n  if (declare) {\n    this.word(\"declare\");\n    this.space();\n  }\n  this.word(\"interface\");\n  this.space();\n  this.print(id);\n  this.print(typeParameters);\n  if (extendz?.length) {\n    this.space();\n    this.word(\"extends\");\n    this.space();\n    this.printList(extendz);\n  }\n  this.space();\n  this.print(body);\n}\n\nexport function TSInterfaceBody(this: Printer, node: t.TSInterfaceBody) {\n  printBraced(this, node, () => this.printJoin(node.body, true, true));\n}\n\nexport function TSTypeAliasDeclaration(\n  this: Printer,\n  node: t.TSTypeAliasDeclaration,\n) {\n  const { declare, id, typeParameters, typeAnnotation } = node;\n  if (declare) {\n    this.word(\"declare\");\n    this.space();\n  }\n  this.word(\"type\");\n  this.space();\n  this.print(id);\n  this.print(typeParameters);\n  this.space();\n  this.token(\"=\");\n  this.space();\n  this.print(typeAnnotation);\n  this.semicolon();\n}\n\nfunction TSTypeExpression(\n  this: Printer,\n  node: t.TSAsExpression | t.TSSatisfiesExpression,\n) {\n  const { type, expression, typeAnnotation } = node;\n  this.print(expression, true);\n  this.space();\n  this.word(type === \"TSAsExpression\" ? \"as\" : \"satisfies\");\n  this.space();\n  this.print(typeAnnotation);\n}\n\nexport {\n  TSTypeExpression as TSAsExpression,\n  TSTypeExpression as TSSatisfiesExpression,\n};\n\nexport function TSTypeAssertion(this: Printer, node: t.TSTypeAssertion) {\n  const { typeAnnotation, expression } = node;\n  this.token(\"<\");\n  this.print(typeAnnotation);\n  this.token(\">\");\n  this.space();\n  this.print(expression);\n}\n\nexport function TSInstantiationExpression(\n  this: Printer,\n  node: t.TSInstantiationExpression,\n) {\n  this.print(node.expression);\n  this.print(node.typeParameters);\n}\n\nexport function TSEnumDeclaration(this: Printer, node: t.TSEnumDeclaration) {\n  const { declare, const: isConst, id, members } = node;\n  if (declare) {\n    this.word(\"declare\");\n    this.space();\n  }\n  if (isConst) {\n    this.word(\"const\");\n    this.space();\n  }\n  this.word(\"enum\");\n  this.space();\n  this.print(id);\n  this.space();\n\n  printBraced(this, node, () =>\n    this.printList(\n      members,\n      // TODO: Default to false for consistency with everything else\n      this.shouldPrintTrailingComma(\"}\") ?? true,\n      true,\n      true,\n    ),\n  );\n}\n\nexport function TSEnumMember(this: Printer, node: t.TSEnumMember) {\n  const { id, initializer } = node;\n  this.print(id);\n  if (initializer) {\n    this.space();\n    this.token(\"=\");\n    this.space();\n    this.print(initializer);\n  }\n}\n\nexport function TSModuleDeclaration(\n  this: Printer,\n  node: t.TSModuleDeclaration,\n) {\n  const { declare, id, kind } = node;\n\n  if (declare) {\n    this.word(\"declare\");\n    this.space();\n  }\n\n  if (process.env.BABEL_8_BREAKING) {\n    if (kind !== \"global\") {\n      this.word(kind);\n      this.space();\n    }\n\n    this.print(node.id);\n    if (!node.body) {\n      this.semicolon();\n      return;\n    }\n    this.space();\n    this.print(node.body);\n  } else {\n    // @ts-ignore(Babel 7 vs Babel 8) Babel 7 AST shape\n    if (!node.global) {\n      this.word(kind ?? (id.type === \"Identifier\" ? \"namespace\" : \"module\"));\n      this.space();\n    }\n\n    this.print(id);\n\n    if (!node.body) {\n      this.semicolon();\n      return;\n    }\n\n    let body = node.body;\n    // @ts-ignore(Babel 7 vs Babel 8) Babel 7 AST shape\n    while (body.type === \"TSModuleDeclaration\") {\n      this.token(\".\");\n      // @ts-ignore(Babel 7 vs Babel 8) Babel 7 AST shape\n      this.print(body.id);\n      // @ts-ignore(Babel 7 vs Babel 8) Babel 7 AST shape\n      body = body.body;\n    }\n\n    this.space();\n    this.print(body);\n  }\n}\n\nexport function TSModuleBlock(this: Printer, node: t.TSModuleBlock) {\n  printBraced(this, node, () => this.printSequence(node.body, true));\n}\n\nexport function TSImportType(this: Printer, node: t.TSImportType) {\n  const { argument, qualifier, typeParameters } = node;\n  this.word(\"import\");\n  this.token(\"(\");\n  this.print(argument);\n  this.token(\")\");\n  if (qualifier) {\n    this.token(\".\");\n    this.print(qualifier);\n  }\n  if (typeParameters) {\n    this.print(typeParameters);\n  }\n}\n\nexport function TSImportEqualsDeclaration(\n  this: Printer,\n  node: t.TSImportEqualsDeclaration,\n) {\n  const { isExport, id, moduleReference } = node;\n  if (isExport) {\n    this.word(\"export\");\n    this.space();\n  }\n  this.word(\"import\");\n  this.space();\n  this.print(id);\n  this.space();\n  this.token(\"=\");\n  this.space();\n  this.print(moduleReference);\n  this.semicolon();\n}\n\nexport function TSExternalModuleReference(\n  this: Printer,\n  node: t.TSExternalModuleReference,\n) {\n  this.token(\"require(\");\n  this.print(node.expression);\n  this.token(\")\");\n}\n\nexport function TSNonNullExpression(\n  this: Printer,\n  node: t.TSNonNullExpression,\n) {\n  this.print(node.expression);\n  this.token(\"!\");\n}\n\nexport function TSExportAssignment(this: Printer, node: t.TSExportAssignment) {\n  this.word(\"export\");\n  this.space();\n  this.token(\"=\");\n  this.space();\n  this.print(node.expression);\n  this.semicolon();\n}\n\nexport function TSNamespaceExportDeclaration(\n  this: Printer,\n  node: t.TSNamespaceExportDeclaration,\n) {\n  this.word(\"export\");\n  this.space();\n  this.word(\"as\");\n  this.space();\n  this.word(\"namespace\");\n  this.space();\n  this.print(node.id);\n  this.semicolon();\n}\n\nexport function tsPrintSignatureDeclarationBase(this: Printer, node: any) {\n  const { typeParameters } = node;\n  const parameters = process.env.BABEL_8_BREAKING\n    ? node.params\n    : node.parameters;\n  this.print(typeParameters);\n  this.token(\"(\");\n  this._parameters(parameters, \")\");\n  const returnType = process.env.BABEL_8_BREAKING\n    ? node.returnType\n    : node.typeAnnotation;\n  this.print(returnType);\n}\n\nexport function tsPrintClassMemberModifiers(\n  this: Printer,\n  node:\n    | t.ClassProperty\n    | t.ClassAccessorProperty\n    | t.ClassMethod\n    | t.ClassPrivateMethod\n    | t.TSDeclareMethod,\n) {\n  const isField =\n    node.type === \"ClassAccessorProperty\" || node.type === \"ClassProperty\";\n  printModifiersList(this, node, [\n    isField && node.declare && \"declare\",\n    node.accessibility,\n  ]);\n  if (node.static) {\n    this.word(\"static\");\n    this.space();\n  }\n  printModifiersList(this, node, [\n    node.override && \"override\",\n    node.abstract && \"abstract\",\n    isField && node.readonly && \"readonly\",\n  ]);\n}\n\nfunction printBraced(printer: Printer, node: t.Node, cb: () => void) {\n  printer.token(\"{\");\n  const exit = printer.enterDelimited();\n  cb();\n  exit();\n  printer.rightBrace(node);\n}\n\nfunction printModifiersList(\n  printer: Printer,\n  node: t.Node,\n  modifiers: (string | false | null)[],\n) {\n  const modifiersSet = new Set<string>();\n  for (const modifier of modifiers) {\n    if (modifier) modifiersSet.add(modifier);\n  }\n\n  printer.tokenMap?.find(node, tok => {\n    if (modifiersSet.has(tok.value)) {\n      printer.token(tok.value);\n      printer.space();\n      modifiersSet.delete(tok.value);\n      return modifiersSet.size === 0;\n    }\n  });\n\n  for (const modifier of modifiersSet) {\n    printer.word(modifier);\n    printer.space();\n  }\n}\n"],"mappings":"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","ignoreList":[]},"metadata":{},"sourceType":"script","externalDependencies":[]}